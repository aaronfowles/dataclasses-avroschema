{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dataclasses Avro Schema Generator Generate Avro Schemas from a Python class Requirements: python 3.7+ Installation pip install dataclasses-avroschema Usage: from dataclasses_avroschema import SchemaGenerator class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None user_avro_schema = SchemaGenerator ( User ) . avro_schema () print ( user_avro_schema ) '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } ' TODO: Schema relations Recursive Schemas Support for Avro Logical Types Custom Exceptions?","title":"Introduction"},{"location":"#dataclasses-avro-schema-generator","text":"Generate Avro Schemas from a Python class","title":"Dataclasses Avro Schema Generator"},{"location":"#requirements","text":"python 3.7+","title":"Requirements:"},{"location":"#installation","text":"pip install dataclasses-avroschema","title":"Installation"},{"location":"#usage","text":"from dataclasses_avroschema import SchemaGenerator class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None user_avro_schema = SchemaGenerator ( User ) . avro_schema () print ( user_avro_schema ) '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } '","title":"Usage:"},{"location":"#todo","text":"Schema relations Recursive Schemas Support for Avro Logical Types Custom Exceptions?","title":"TODO:"},{"location":"avro_schema/","text":"Avro Schemas and Python Class What is Apache Avro? Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON) Goal Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is. Records Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] } From a Python class to the Avo Schema Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema import SchemaGenerator class User : name : str age : int has_pets : bool money : float SchemaGenerator ( User ) . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" } , { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships (here)[https://marcosschroh.github.io/dataclasses-avroschema/fields_specification/]: Enum, Array and Map fields class UserAdvance : name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ 'dog' , 'cat' ]) # array field with default accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) # map field with default has_car : bool = False favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) # enum field country : str = \"Argentina\" address : str = None SchemaGenerator ( UserAdvance , include_schema_doc = False ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pets\" }, \"default\" : [ \"dog\" , \"cat\" ] }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"accounts\" }, \"default\" : { \"key\" : 1 } }, { \"name\" : \"has_car\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_colors\" } }, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } ' Special Avro attributes There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"money\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } '","title":"Avro Schema and Python Classes"},{"location":"avro_schema/#avro-schemas-and-python-class","text":"","title":"Avro Schemas and Python Class"},{"location":"avro_schema/#what-is-apache-avro","text":"Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON)","title":"What is Apache Avro?"},{"location":"avro_schema/#goal","text":"Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is.","title":"Goal"},{"location":"avro_schema/#records","text":"Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] }","title":"Records"},{"location":"avro_schema/#from-a-python-class-to-the-avo-schema","text":"Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema import SchemaGenerator class User : name : str age : int has_pets : bool money : float SchemaGenerator ( User ) . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" } , { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships (here)[https://marcosschroh.github.io/dataclasses-avroschema/fields_specification/]:","title":"From a Python class to the Avo Schema"},{"location":"avro_schema/#enum-array-and-map-fields","text":"class UserAdvance : name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ 'dog' , 'cat' ]) # array field with default accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) # map field with default has_car : bool = False favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) # enum field country : str = \"Argentina\" address : str = None SchemaGenerator ( UserAdvance , include_schema_doc = False ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pets\" }, \"default\" : [ \"dog\" , \"cat\" ] }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"accounts\" }, \"default\" : { \"key\" : 1 } }, { \"name\" : \"has_car\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_colors\" } }, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } '","title":"Enum, Array and Map fields"},{"location":"avro_schema/#special-avro-attributes","text":"There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"money\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } '","title":"Special Avro attributes"},{"location":"fields_specification/","text":"Avro Fields and Python Fields Apache Avro has Primitive Types and Complex Types , so we need to match these types with python types. Primitive Types and python representation The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int long int boolean bool float float double float null None bytes wip Example: class User : name : str age : int has_pets : bool money : float # some with default values country : str = \"Argentina\" address : str = None total_houses : int = 1 has_car : bool = False Complex Types Avro supports six kinds of complex types: records, enums, arrays, maps, unions and fixed. Enums Enums use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). For example, playing card suits might be defined with: { \"type\" : \"enum\" , \"name\" : \"Suit\" , \"symbols\" : [ \"SPADES\" , \"HEARTS\" , \"DIAMONDS\" , \"CLUBS\" ] } The enum type is mapped to a python tuple . Example: class User : ... favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays Arrays use the type name \"array\" and support a single attribute: items: the schema of the array's items. For example, an array of strings is declared with: { \"type\" : \"array\" , \"items\" : \"string\" } The array type is mapped to a python list . Example: class UserAdvance : ... pets : typing . List [ str ] cars : typing . List [ str ] = None Maps Maps use the type name \"map\" and support one attribute: values: the schema of the map's values. Map keys are assumed to be strings. For example, a map from string to long is declared with: { \"type\" : \"map\" , \"values\" : \"long\" } The array type is mapped to a python dict where all the keys should be string . Example: class UserAdvance : ... accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None Records Records use the type name \"record\" and will represent the \"Schema\". Avro Field and Python Types Summary Avro Type Python Type string str int int long int boolean bool float float null None double wip bytes wip enum tuple array list map dict record Python class","title":"Fields Specification"},{"location":"fields_specification/#avro-fields-and-python-fields","text":"Apache Avro has Primitive Types and Complex Types , so we need to match these types with python types.","title":"Avro Fields and Python Fields"},{"location":"fields_specification/#primitive-types-and-python-representation","text":"The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int long int boolean bool float float double float null None bytes wip Example: class User : name : str age : int has_pets : bool money : float # some with default values country : str = \"Argentina\" address : str = None total_houses : int = 1 has_car : bool = False","title":"Primitive Types and python representation"},{"location":"fields_specification/#complex-types","text":"Avro supports six kinds of complex types: records, enums, arrays, maps, unions and fixed.","title":"Complex Types"},{"location":"fields_specification/#enums","text":"Enums use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). For example, playing card suits might be defined with: { \"type\" : \"enum\" , \"name\" : \"Suit\" , \"symbols\" : [ \"SPADES\" , \"HEARTS\" , \"DIAMONDS\" , \"CLUBS\" ] } The enum type is mapped to a python tuple . Example: class User : ... favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this","title":"Enums"},{"location":"fields_specification/#arrays","text":"Arrays use the type name \"array\" and support a single attribute: items: the schema of the array's items. For example, an array of strings is declared with: { \"type\" : \"array\" , \"items\" : \"string\" } The array type is mapped to a python list . Example: class UserAdvance : ... pets : typing . List [ str ] cars : typing . List [ str ] = None","title":"Arrays"},{"location":"fields_specification/#maps","text":"Maps use the type name \"map\" and support one attribute: values: the schema of the map's values. Map keys are assumed to be strings. For example, a map from string to long is declared with: { \"type\" : \"map\" , \"values\" : \"long\" } The array type is mapped to a python dict where all the keys should be string . Example: class UserAdvance : ... accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None","title":"Maps"},{"location":"fields_specification/#records","text":"Records use the type name \"record\" and will represent the \"Schema\".","title":"Records"},{"location":"fields_specification/#avro-field-and-python-types-summary","text":"Avro Type Python Type string str int int long int boolean bool float float null None double wip bytes wip enum tuple array list map dict record Python class","title":"Avro Field and Python Types Summary"}]}