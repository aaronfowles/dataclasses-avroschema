{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dataclasses Avro Schema Generator Generate Avro Schemas from a Python class Requirements: python 3.7+ Installation pip install dataclasses-avroschema Usage: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } ' Features: [X] int, long, float, boolean, string and null support [X] enum, array, map and records support [X] Schema relations (oneToOne, oneToMany) [x] Recursive Schemas [x] Support for Avro Logical Types (Date, Time, Datetime, UUID) [ ] Decimal Logical Types","title":"Introduction"},{"location":"#dataclasses-avro-schema-generator","text":"Generate Avro Schemas from a Python class","title":"Dataclasses Avro Schema Generator"},{"location":"#requirements","text":"python 3.7+","title":"Requirements:"},{"location":"#installation","text":"pip install dataclasses-avroschema","title":"Installation"},{"location":"#usage","text":"from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } '","title":"Usage:"},{"location":"#features","text":"[X] int, long, float, boolean, string and null support [X] enum, array, map and records support [X] Schema relations (oneToOne, oneToMany) [x] Recursive Schemas [x] Support for Avro Logical Types (Date, Time, Datetime, UUID) [ ] Decimal Logical Types","title":"Features:"},{"location":"avro_schema/","text":"Avro Schemas and Python Class What is Apache Avro? Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON) Goal Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is. Records Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] } From a Python class to the Avo Schema Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : name : str age : int has_pets : bool money : float SchemaGenerator ( User ) . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships (here)[https://marcosschroh.github.io/dataclasses-avroschema/fields_specification/]: Enum, Array and Map fields import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class UserAdvance : name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ 'dog' , 'cat' ]) # array field with default accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) # map field with default has_car : bool = False favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) # enum field country : str = \"Argentina\" address : str = None SchemaGenerator ( UserAdvance , include_schema_doc = False ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }, \"default\" : [ \"dog\" , \"cat\" ] }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"account\" }, \"default\" : { \"key\" : 1 } }, { \"name\" : \"has_car\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" } }, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } ' Special Avro attributes There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"money\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } '","title":"Avro Schema and Python Classes"},{"location":"avro_schema/#avro-schemas-and-python-class","text":"","title":"Avro Schemas and Python Class"},{"location":"avro_schema/#what-is-apache-avro","text":"Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON)","title":"What is Apache Avro?"},{"location":"avro_schema/#goal","text":"Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is.","title":"Goal"},{"location":"avro_schema/#records","text":"Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] }","title":"Records"},{"location":"avro_schema/#from-a-python-class-to-the-avo-schema","text":"Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : name : str age : int has_pets : bool money : float SchemaGenerator ( User ) . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships (here)[https://marcosschroh.github.io/dataclasses-avroschema/fields_specification/]:","title":"From a Python class to the Avo Schema"},{"location":"avro_schema/#enum-array-and-map-fields","text":"import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class UserAdvance : name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ 'dog' , 'cat' ]) # array field with default accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) # map field with default has_car : bool = False favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) # enum field country : str = \"Argentina\" address : str = None SchemaGenerator ( UserAdvance , include_schema_doc = False ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }, \"default\" : [ \"dog\" , \"cat\" ] }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"account\" }, \"default\" : { \"key\" : 1 } }, { \"name\" : \"has_car\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" } }, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } '","title":"Enum, Array and Map fields"},{"location":"avro_schema/#special-avro-attributes","text":"There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"money\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } '","title":"Special Avro attributes"},{"location":"fields_specification/","text":"Avro Fields and Python Fields Apache Avro has Primitive Types and Complex Types , so we need to match these types with python types. Primitive Types and python representation The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int long int boolean bool float float double float null None bytes wip Example: class User : name : str age : int has_pets : bool money : float # some with default values country : str = \"Argentina\" address : str = None total_houses : int = 1 has_car : bool = False Complex Types Avro supports six kinds of complex types: records, enums, arrays, maps, unions and fixed. Enums Enums use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). For example, playing card suits might be defined with: { \"type\" : \"enum\" , \"name\" : \"Suit\" , \"symbols\" : [ \"SPADES\" , \"HEARTS\" , \"DIAMONDS\" , \"CLUBS\" ] } The enum type is mapped to a python tuple . Example: import typing class User : ... favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays Arrays use the type name \"array\" and support a single attribute: items: the schema of the array's items. For example, an array of strings is declared with: { \"type\" : \"array\" , \"items\" : \"string\" } The array type is mapped to a python list . Example: import typing class UserAdvance : ... pets : typing . List [ str ] cars : typing . List [ str ] = None Maps Maps use the type name \"map\" and support one attribute: values: the schema of the map's values. Map keys are assumed to be strings. For example, a map from string to long is declared with: { \"type\" : \"map\" , \"values\" : \"long\" } The array type is mapped to a python dict where all the keys should be string . Example: import typing class UserAdvance : ... accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None Records Records use the type name \"record\" and will represent the \"Schema\". Avro Field and Python Types Summary Avro Type Python Type string str int int long int boolean bool float float null None double wip bytes wip enum tuple array list map dict record Python class Logical Types A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4","title":"Fields Specification"},{"location":"fields_specification/#avro-fields-and-python-fields","text":"Apache Avro has Primitive Types and Complex Types , so we need to match these types with python types.","title":"Avro Fields and Python Fields"},{"location":"fields_specification/#primitive-types-and-python-representation","text":"The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int long int boolean bool float float double float null None bytes wip Example: class User : name : str age : int has_pets : bool money : float # some with default values country : str = \"Argentina\" address : str = None total_houses : int = 1 has_car : bool = False","title":"Primitive Types and python representation"},{"location":"fields_specification/#complex-types","text":"Avro supports six kinds of complex types: records, enums, arrays, maps, unions and fixed.","title":"Complex Types"},{"location":"fields_specification/#enums","text":"Enums use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). For example, playing card suits might be defined with: { \"type\" : \"enum\" , \"name\" : \"Suit\" , \"symbols\" : [ \"SPADES\" , \"HEARTS\" , \"DIAMONDS\" , \"CLUBS\" ] } The enum type is mapped to a python tuple . Example: import typing class User : ... favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this","title":"Enums"},{"location":"fields_specification/#arrays","text":"Arrays use the type name \"array\" and support a single attribute: items: the schema of the array's items. For example, an array of strings is declared with: { \"type\" : \"array\" , \"items\" : \"string\" } The array type is mapped to a python list . Example: import typing class UserAdvance : ... pets : typing . List [ str ] cars : typing . List [ str ] = None","title":"Arrays"},{"location":"fields_specification/#maps","text":"Maps use the type name \"map\" and support one attribute: values: the schema of the map's values. Map keys are assumed to be strings. For example, a map from string to long is declared with: { \"type\" : \"map\" , \"values\" : \"long\" } The array type is mapped to a python dict where all the keys should be string . Example: import typing class UserAdvance : ... accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None","title":"Maps"},{"location":"fields_specification/#records","text":"Records use the type name \"record\" and will represent the \"Schema\".","title":"Records"},{"location":"fields_specification/#avro-field-and-python-types-summary","text":"Avro Type Python Type string str int int long int boolean bool float float null None double wip bytes wip enum tuple array list map dict record Python class","title":"Avro Field and Python Types Summary"},{"location":"fields_specification/#logical-types","text":"A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4","title":"Logical Types"},{"location":"logical_types/","text":"Schema with Logical Types import datetime import uuid from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class LogicalTypes : \"Some logical types\" birthday : datetime . date = a_datetime . date () meeting_time : datetime . time = a_datetime . time () release_datetime : datetime . datetime = a_datetime event_uuid : uuid . uuid4 = uuid . uuid4 () SchemaGenerator ( LogicalTypes ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"LogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"42b8ed8b-ca4a-4d72-91bd-6722c80b9416\" } ], \"doc\" : \"Some logical types\" } '","title":"Logical Types"},{"location":"logical_types/#schema-with-logical-types","text":"import datetime import uuid from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class LogicalTypes : \"Some logical types\" birthday : datetime . date = a_datetime . date () meeting_time : datetime . time = a_datetime . time () release_datetime : datetime . datetime = a_datetime event_uuid : uuid . uuid4 = uuid . uuid4 () SchemaGenerator ( LogicalTypes ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"LogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"42b8ed8b-ca4a-4d72-91bd-6722c80b9416\" } ], \"doc\" : \"Some logical types\" } '","title":"Schema with Logical Types"},{"location":"schema_relationships/","text":"OneToOne Schema Relationship An User has one Address example: from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"An User with Address\" name : str age : int address : Address SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } ' OneToOne Recursive Schema Relationship An User with only one friend :-( : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friend\" , \"type\" : \"User\" } ], \"doc\" : \"User with self reference as friend\" } ' OneToMany Schema Relationship An User has multiple Address example: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' or OneToMany using a Map: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' OneToMany Recursive Schema Relationship An User with multiple friends :-) : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator # Using a List (Avro Array) class User : \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User : \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } '","title":"Schema Relationships"},{"location":"schema_relationships/#onetoone-schema-relationship","text":"An User has one Address example: from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"An User with Address\" name : str age : int address : Address SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } '","title":"OneToOne Schema Relationship"},{"location":"schema_relationships/#onetoone-recursive-schema-relationship","text":"An User with only one friend :-( : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friend\" , \"type\" : \"User\" } ], \"doc\" : \"User with self reference as friend\" } '","title":"OneToOne Recursive Schema Relationship"},{"location":"schema_relationships/#onetomany-schema-relationship","text":"An User has multiple Address example: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' or OneToMany using a Map: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } '","title":"OneToMany Schema Relationship"},{"location":"schema_relationships/#onetomany-recursive-schema-relationship","text":"An User with multiple friends :-) : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator # Using a List (Avro Array) class User : \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User : \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } '","title":"OneToMany Recursive Schema Relationship"}]}